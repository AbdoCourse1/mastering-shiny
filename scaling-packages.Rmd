# Packages {#scaling-packaging}

```{r, include = FALSE}
source("common.R")
options(tibble.print_min = 6, tibble.print_max = 6)
```

If you are creating a large/long-term Shiny app, I strongly recommend that you organise your app in the same way you'd organise an R package. This means three things:

-   You put all of your R code in `R/`.

-   You have a function that creates your app (i.e. calls `shinyApp()` with your UI and server)

-   You have a `DESCRIPTION` file.

This structure gets your toes in the water of package development. It's a long way from a complete package, but still useful because it activates new tools that make it easier to work with larger amounts of code. The investment in creating a package will pay off further when we talk about testing your app in Chapter \@ref(scaling-testing), because you get a bunch more tools that make it easy to run to tests and to see exactly what code you're testing. It also helps you document the pieces of complex apps, although we won't discuss that in this book.

It's easy to think of packages as these big complicated artefacts like Shiny, ggplot2, or dplyr. But packages can also be very simple, and at their heart, the key idea of a package is that it's a set of conventions for organising your code and related artifcats. In this chapter, I'll start by showing you how to achieve the absolute minimal compliance with the standard.

As you start working with apps in this structure, you may find that you enjoy the process and want to learn more. In this chapter, I'll provide a few hints as to next steps (most importantly getting `R CMD check` to pass), but if you want to learn more about R packages I recommend *[R Packages](https://r-pkgs.org){.uri}*, and if you want to learn more about the intersection of R packages and Shiny apps, I highly recommend *[Engineering Shiny](http://engineering-shiny.org/){.uri}*, by Colin Fay, Sébastien Rochette, Vincent Guyader, Cervan Girard.

```{r setup}
library(shiny)
```

## Converting an existing app

Converting an app to a package requires a small little work. Follow these steps to create an package. I'm assuming that your app is called `myApp` and it already lives in a directory called `myApp/`.

-   If it doesn't exist already, create an `R` directory.

-   Move `app.R` into `R/` and wrap the existing call to `shinyApp()` in a function called `myApp()`:

    ```{r}
    myApp <- function(...) {
      shinyApp(ui, server, ...)
    }
    ```

-   If you're deploying your app (not just running it locally), you'll need to a add a new `app.R` that tells the deployment server how you run your app. The easiest way is to load the code with pkgload:

    ```{r, eval = FALSE}
    pkgload::load_all()
    myApp::myApp()
    ```

    (Inspired by <https://engineering-shiny.org/structure.html#deploy>).

-   Call `usethis::use_description()` to create a description file. You don't have to even look at or touch this file (although you need to if you want to make a full package), but you need to have it to activate RStudio's "package development mode" which provides the keyboard shortcuts we'll use later.

-   Restart RStudio.

This gives your app the basic structure of a package, which enables some useful keyboard shortcuts that we'll talk about next. It's possible to turn your app in to a "real" package, which means that it passes the automated `R CMD check`. That's not essential, but it can be useful if you're sharing with others.

## Workflow

-   Re-load all code in the app with `cmd + shift + L` (`devtools::load_all()`).

-   Re-run the app with `myApp()`.

## `R CMD check`

You may also want to use `devtools::check()` which calls `R CMD check` and ensures that your app is fully compliant with the package standard. In the short term, this is often quite a lot of work for relatively little pay off. But in the long-term this will protect you against a number of potential problems, and because it adheres to common conventionsin the R community, it makes it easier for others to contribute to your app.

I don't recommend that you do this the first time you try out the package structure; I include these notes for when you come back to it in the future.

To make an app pass `R CMD check`, you'll also need to:

-   Remove any calls to `library()` or `require()` and instead replace them with a declaration in your `DESCRIPTION`. `usethis::use_package("name")` to add the required package to the `DESCRIPTION`[^1].

    At a minimum, you'll need `usethis::use_package("shiny")`!.

    Need to decide whether to use depends or be explicit with namespace. The first is easy, the second is a little more work but makes it easier to understand where functions are coming from

-   `use_license_…()` (<https://github.com/r-lib/usethis/issues/1163>)

-   Add `app.R` to `.Rbuildignore` with `usethis::use_build_ignore("app.R")` or similar.

-   Document and export your app function.

-   If you app contains small reference datasets put it in `data` or `inst/extdata`. Advantage of `data/` is that it's stored in `.rda` format, which is faster to load, and is lazy loaded so if it's not used by the app, it's not loaded in memory. (Although if that's a bottleneck you might want qs instead). Load using `system.file("exdata", "path", package = "myApp")`.

-   Remove any calls to `source()` or `shiny::loadSupport()`. The package code loading process now takes care of these.

-   Files in `www`? `inst/www`?

-   You can also change your `app.R` to use an the package. This requires that your available somewhere that your deployment machine can install from. For public work this means a CRAN or GitHub package; for private work this means something like RSPM.

    ```{r, eval = FALSE}
    library(myApp)
    myApp::myApp()
    ```

[^1]: The distinction between Imports and Suggests is not generally important for app packages. If you do want to make a distinction, the most useful is to use Imports for packages that need to be present on the deployment machine (in order for the app to work) and Suggests for packages that need to prsent on the development machine in order to develop the app.
