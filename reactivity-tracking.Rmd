# The reactive graph {#dependency-tracking}

```{r include=FALSE}
source("common.R")
```

## Introduction

To understand reactive computation you must first understand the reactive graph.
In this chapter, we'll dive in to the details of the graph, paying much more attention to precise order in which things happen.
In particular, you'll learn about the importance of invalidation, which helps ensure that Shiny does the minimum amount of work needed.
You'll also learn about the reactlog package which can automatically draw the reactive graph for you.

Before you read this chapter, I highly recommend that you re-read Chapter \@ref(basic-reactivity) if it's been a while since you looked at it.
That chapter lays the ground work for the concepts that we'll explore in more detail.

```{r}
library(shiny)
```

## A step-by-step tour of reactive execution {#step-through}

To explain the process of reactive execution, we'll use the graphic shown in Figure \@ref(fig:graph-complete).
It contains three reactive inputs, three reactive expressions, and three outputs[^reactivity-tracking-1].
Recall that reactive inputs and expressions are reactive producers; and reactive expressions and outputs are reactive consumers.

[^reactivity-tracking-1]: Anywhere you see output, you can also think observer.
    The only difference is that outputs that aren't visible on screen will never be computed.

```{r graph-complete, echo = FALSE, out.width = NULL, fig.cap = "Complete reactive graph of an imaginary app containing three inputs, three reactive expressions, and three outputs."}
knitr::include_graphics("diagrams/reactivity-tracking/08.png", dpi = 300)
```

The underlying app is not important, but if you want something concrete, the following silly app matches the graph.

```{r}
ui <- fluidPage(
  numericInput("a", "a", value = 1),
  numericInput("b", "b", value = 1),
  numericInput("c", "c", value = 1),
  textOutput("x"),
  textOutput("y"),
  textOutput("z")
)
server <- function(input, output, session) {
  two_a <- reactive(input$a * 2)
  two_a_b <- reactive(two_a() + input$b)
  b_c <- reactive(input$b * input$c)
  
  output$x <- renderText(two_a_b())
  output$y <- renderText(two_a_b())
  output$z <- renderText(b_c())
}
```

The connections between the components are directional, with the arrows indicating the direction of reactivity.
The direction might surprise you.
It's easy to think about a reactive consumer depending on reactive producers, but shortly we'll see that the flow of reactivity is better thought of travelling in the opposite direction.

Figure \@ref(fig:graph-complete) shows the final state of the app --- all reactive relationships have been discovered, and all the computation has complete (illustrated using green).
Now we'll work step by step to see how we get to this point from loading a Shiny app.

### A session begins

Figure \@ref(fig:graph-init) shows the initial state of the graph, right after the app has started and the server function has been executed for the first time.
There are no connections because Shiny has no *a priori* knowledge of the relationships, and all the reactive consumers are grey.
We use grey to indicate that the reactive consumers are **invalidated**, which means that they haven't yet been run.

```{r graph-init, echo = FALSE, out.width = NULL, fig.cap = "Initial state after app load. There are no connections between objects and all reactive expressions are invalidated (grey)."}
knitr::include_graphics("diagrams/reactivity-tracking/01.png", dpi = 300)
```

### Execution begins

Now we start the execution phase, as shown in Figure \@ref(fig:graph-execute).
In this phase, Shiny picks an invalidated observer or on-screen output and starts executing it.
You might wonder how Shiny decides which of the invalidated observers/outputs to execute.
In short, you should act as if it's random: your observers and outputs shouldn't care what order they execute in, because they've been designed to function independently[^reactivity-tracking-2].

[^reactivity-tracking-2]: If have observers whose side effects must happen in a certain order, you're generally better off re-designing your system.
    Failing that, you can control the relative order of observers with the the `priority` argument to `observe()`.

```{r graph-execute, echo = FALSE, out.width = NULL, fig.cap = "Next Shiny starts executing an arbitrary observer/output, coloured orange."}
knitr::include_graphics("diagrams/reactivity-tracking/02.png", dpi = 300)
```

### Reading a reactive expression

During an output's execution, it may read from one or more reactive producers, as in Figure \@ref(fig:graph-read-reactive).

```{r graph-read-reactive, echo = FALSE, out.width = NULL, fig.cap = "The output needs the value of a reactive expression, so it starts executing."}
knitr::include_graphics("diagrams/reactivity-tracking/03.png", dpi = 300)
```

Two things happen here:

-   The reactive expression is invalidated, so it needs to start computing its value, i.e. it turns orange.
    Note that the output is still orange: just because the reactive expression is now running, doesn't mean that the output has finished.
    The output is waiting on the reactive expression to return its value so its own execution can continue, just like a regular function call in R.

-   Shiny records a relationship between the output and reactive expression, i.e. we draw an arrow.
    The direction of the arrow is important: it is the expression that records that it's used by an output.
    We'll come back to the details of this in Section \@ref(how-it-works).

### Reading an input

This particular reactive expression happens to read a reactive input.
Again, a dependency/dependent relationship is established, so in Figure \@ref(fig:graph-read-input) we add another arrow.
Unlike reactive expressions and outputs, reactive inputs have nothing to execute, since they just represent a value.

```{r graph-read-input, echo = FALSE, out.width = NULL, fig.cap = "The reactive expression also reads from a reactive value, so we add another arrow."}
knitr::include_graphics("diagrams/reactivity-tracking/04.png", dpi = 300)
```

### Reactive expression completes

In our example, the reactive expression reads another reactive expression, which in turn reads another input.
We'll skip over the blow-by-blow description of those steps, since they're just a repeat of what we've already described, and jump directly to Figure \@ref(fig:graph-reactive-complete).

Now that the reactive expression has finished executing it turns green to indicate that it's up-to-date.
It cache the resulting value internally before returning it to the output that requested it.

```{r graph-reactive-complete, echo = FALSE, out.width = NULL, fig.caption = "The reactive expression has finished computing so turns green."}
knitr::include_graphics("diagrams/reactivity-tracking/05.png", dpi = 300)
```

### Output completes

Now that the reactive expression has returned its value to the output, the output can finish executing its code, and change colour to green, as in Figure \@ref(fig:graph-output-complete).

```{r graph-output-complete, echo = FALSE, out.width = NULL, fig.cap = "The output has finished computation and turns green."}
knitr::include_graphics("diagrams/reactivity-tracking/06.png", dpi = 300)
```

### The next output executes

Now that Shiny has executed of the first output, it chooses a second one to execute.
It turns orange, Figure \@ref(fig:graph-output-next) and starts reading values from reactive producers.
Complete reactives can return their values immediately; invalidated reactives will kick of their own execution graph.
This cycle will repeat until every invalidated output enters the complete (green) state.

```{r graph-output-next, echo = FALSE, out.width = NULL, fig.cap ="The next output starts computing, turning orange."}
knitr::include_graphics("diagrams/reactivity-tracking/07.png", dpi = 300)
```

### Execution completes, outputs flushed

Now in Figure \@ref(fig:graph-complete-2), all of the outputs have finished execution and are now idle.
This round of reactive execution is complete, and nothing will happen with this session until some external force acts on the system (e.g. the user of the Shiny app moving a slider in the user interface).
In reactive terms, this session is now at rest.

```{r graph-complete-2, echo = FALSE, out.width = NULL, fig.caption = "All output and reactive expressions have finished and turned green."}
knitr::include_graphics("diagrams/reactivity-tracking/08.png", dpi = 300)
```

Let's stop here for just a moment and think about what we've done.
We've read some inputs, calculated some values, and generated some outputs.
But more importantly, in the course of doing that work, we also discovered the *relationships* between the reactive objects.
Now when a reactive input changes we know to invalidate reactive expressions and re-run outputs.

Just as importantly we also know which nodes are *not* dependent on each other: if no path exists from a reactive input to a output, then changing the input can't affect the output.
That allows Shiny to do the minimum amount of re-computation when an input changes.

### An input changes

The previous step left off with our Shiny session in a fully idle state.
Now imagine that the user of the application changes the value of a slider.
This causes the browser to send a message to their server, instructing Shiny to update the corresponding reactive input.

When a reactive input or value is modified, it kicks off an **invalidation phase**.
The invalidation phase starts at the changed input/value, which in Figure \@ref(fig:graph-input-changes) we'll fill with grey, our usual colour for invalidation.

```{r graph-input-changes, echo = FALSE, out.width = NULL, fig.cap = "The user interacts with the app, invalidating an input."}
knitr::include_graphics("diagrams/reactivity-tracking/09.png", dpi = 300)
```

### Notifying dependents

Now, we follow the arrows that we drew earlier.
Each reactive consumer that we find is put into invalidated state, and we keep following the arrows until there's nothing left.
The results of this process are shown in Figure \@ref(fig:graph-invalidation); the arrows we followed are shown in lighter grey.

```{r graph-invalidation, echo = FALSE, out.width = NULL, fig.cap = "Invalidation flows out from the input, following every arrow from left to right."}
knitr::include_graphics("diagrams/reactivity-tracking/10.png", dpi = 300)
```

### Removing relationships

Next, each invalidated reactive expression and output "erases" all of the arrows coming in or out of it, yielding Figure \@ref(fig:graph-forgetting).
You can think of each arrow as a one-shot notification that will fire the *next* time a value changes.
So all of the arrows coming out of a reactive expression are safe to erase; like a used bottle rocket, they've fired their one shot.

Less obvious is why we erase the arrows coming *in* to an invalidated node, even if the node they're coming from isn't invalidated.
While those arrows represent notifications that haven't yet fired, the invalidated node no longer cares about them.
The only reason nodes care about notifications is so they can be invalidated and here that invalidation has already happened due to some other dependency.

```{r graph-forgetting, echo = FALSE, out.width = NULL, fig.cap = "Invalidated nodes forget all their previous relationships so they can be discovered afresh"}
knitr::include_graphics("diagrams/reactivity-tracking/11.png", dpi = 300)
```

It may seem perverse that we put so much value on those relationships, and now we're going out of our way to erase them!
But the truth is, though these particular arrows *were* important, they are now themselves out of date.
The only way to ensure that our graph stays accurate is to erase arrows when they become stale, and let Shiny rediscover the relationships around these nodes as they re-execute.

This marks the end of the invalidation phase.

### Re-execution

Now we're in a pretty similar situation to when the Shiny session first started; we have some invalidated reactive expressions and outputs, and we don't have any arrows coming in or out of them.
It's time to do exactly what we did then: execute the invalidated outputs, one at a time, starting with Figure \@ref(fig:graph-reexec).

```{r graph-reexec, echo = FALSE, out.width = NULL, fig.cap = "Now re-execution proceeds in the same way as execution, but since we're not starting from scratch we don't have as much work to do."}
knitr::include_graphics("diagrams/reactivity-tracking/12.png", dpi = 300)
```

What's different this time, though, is that not all of the reactive expressions and outputs are starting out in the invalidated state.
Some parts of the graph weren't affected so we don't need to re-execute them.

It's also possible that some outputs are no longer visible, and if so they won't be updated.

## The react log

<https://rstudio.github.io/reactlog/>

Can set `label` to make it easier to identify key reactives.
A handy tip is to use emoji.

## Applications

### Conditional dependency

Consider the following simple app:

```{r}
library(shiny)

ui <- fluidPage(
  selectInput("choice", "A or B?", c("a", "b")),
  numericInput("a", "a", 0),
  numericInput("b", "b", 10),
  textOutput("out")
)

server <- function(input, output, session) {
  output$out <- renderText({
    if (input$choice == "a") {
      input$a
    } else {
      input$b
    }
  }) 
}
```

What does the reactive graph to look like?
You might expect to look like this:

But in fact, the graph either looks like this or that, depending on the value of `input$choice`.

This is because shiny dynamically constructs the graph.

Also happens for observers.

```{r}
server <- function(input, output, session) {
  observe({
    if (input$choice == "a") {
      print(input$a)
    } else {
      print(input$b)
    }
  }) 
}
```

### Nested observers

Every time it activates you get one more:

```{r, eval = FALSE}
x <- reactiveVal(1)
y <- observe({
  x()
  observe(print(x()))
})
x(2)
x(3)
```

Not usually this obvious --- same problem occurs whenever you nest an observer in an output function or a output function in an observer.
Might be hard to spot if you have very large blocks --- just another reason to keep your reactive code as minimal as possible.

## How does it work? {#how-it-works}

Before we carry on, I wanted to give you a quick sense of how things work behind the scenes.
This knowledge isn't likely to help you build better apps, but it might resolve some lingering questions.
Take this simple example:

```{r eval = FALSE}
output$plot <- renderPlot({
  plot(head(cars, input$rows))
})
```

How does Shiny know that `output$plot` reads `input$rows`?
Your first guess might be that `renderPlot()` parses its code looking for looking for symbols that seem to be relevant for reactivity.
This is a natural guess because it's how you build up a reactive graph when reading code.

Unfortunately, however, this technique is very fragile because even a change as simple as giving `input` a new name would break things:

```{r eval = FALSE}
output$plot <- renderPlot({
  x <- input
  plot(head(cars, x$rows))
})
```

In compute science this approach is called **static analysis**, because it looks at the code without running it (i.e. it's not moving, it's static).
Instead, Shiny uses **dynamic instrumentation**, where collects additional information about what's going on as it is run.

The basic process is something like this.
`renderPlot()` starts by creating a **reactive context**.
A reactive context is a internal object that is used coordinate reactive consumers and producers.
You'll never see once of these objects as an app author, but they're a crucial piece of infrastructure behind the scenes.

The reactive context is then stored in a special place that's accessible to other Shiny functions.
Once `renderPlot()` is done, it restores the previous context, using something like this imaginary code:

```{r eval=FALSE}
# renderPlot() creates and activate new context 
context <- ReactiveContext$new()
old <- setReactiveContext(context)

# Then we run the user code
plot(head(cars, input$rows))

# And finally restore the previous context
setReactiveContext(old)
```

Now, while a reactive consumer is running, reactive producers can get hold of the active context with `getReactiveContext()`.
Then when the reactive producer is asked for a value, as well as return the value, it also saves the current reactive context.
When the reactive producer is later modified, it iterates through all its saved contexts and invalidates them.
This then invalidates the corresponding reactive consumers.

So Shiny "magically" establishes the connections between producer and consumer with these two simple mechanisms:

-   Each reactive consumer creates a context object and "activates" it during execution.

-   Each reactive producer augments every read operation by saving the context object so it can be later invalidated.

This process ensures that there's no way that Shiny can either accidentally overlook a reactive dependency relationship or erroneously establish a dependency that doesn't exist.
