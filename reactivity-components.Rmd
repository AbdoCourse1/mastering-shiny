# Reactive components {#reactivity-components}

```{r setup, include=FALSE}
source("common.R")
```

## Introduction

Sometimes you need to create new reactive components that don't otherwise exist in Shiny.
These tend to be typically related to managing state over time.
Animations.

If this idea is interesting you might want to read the code in [shinySignals](https://github.com/hadley/shinySignals/), an experimental package that I made to play around with these ideas some time ago.
Wouldn't recommend you use it for anything serious, but reading the source code might be interesting.

```{r}
library(shiny)
```

## Motivation

Here are two simple example of what I mean by accumulating state over time.
In the first example, we have an app with two buttons, that let you increase and decrease values.

```{r}
ui <- fluidPage(
  actionButton("up", "up"),
  actionButton("down", "down"),
  textOutput("n")
)
server <- function(input, output, session) {
  n <- reactiveVal(0)
  observeEvent(input$up, n(n() + 1))
  observeEvent(input$down, n(n() - 1))
  
  output$n <- renderText(n())
}
```

Maintain a growing list of entries

```{r}
ui <- fluidPage(
  textInput("name", "name"),
  actionButton("add", "add"),
  textOutput("names")
)
server <- function(input, output, session) {
  names <- reactiveVal()
  observeEvent(input$add, {
    names(c(input$name, names()))
    updateTextInput(session, "name", value = "")
  })
  
  output$names <- renderText(names())
}
```

Single message that multiple observers can "write" to.
Brushing example using different events.

```{r, eval = FALSE}
message <- reactiveVal()
output$widgets <- renderText(messsage())
```

This feels very much like imperative programming --- when this happens, do that.
This makes it easier to understand on a small scale, but harder to understand when bigger pieces start interacting.
So goal is to keep imperative code isolated inside larger functions.

## Creating components

`reactivePoll()` how is it implemented

Brushing

### Observers vs reactives

One caution --- whenever you use `observe()` you force the computation of all reactive expressions.
Often this is not a big deal, but if you are designing tools that compute on reactives, it's good to know about.

Draw out the graph

```{r}
dedupe <- function(r) {
  stopifnot(is.reactive(r))
  
  prev <- reactiveVal(NULL)
  observe({
    val <- r()
    
    isolate({
      if (!identical(val, prev())) {
        prev(val)
      }
    })
  })
  
  reactive(prev())
}
```

```{r}
dedupe <- function(r) {
  stopifnot(is.reactive(r))
  
  prev <- NULL
  reactive({
    val <- r()
    req(!identical(val, prev))

    prev <<- val
    val
  })
}
```
