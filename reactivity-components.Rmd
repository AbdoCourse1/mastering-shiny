# Escaping the graph {#reactivity-components}

```{r setup, include=FALSE}
source("common.R")
```

## Introduction

Shiny's reactive programming framework is incredibly useful because it automatically determines the minimal set of computations needed to update all outputs when an input changes.
But this framework comes at a cost, and sometimes you need to break free from some of the constraints of reactive programming.
It allows you to do things that you otherwise could not, but you also lose all the protections you normally get.
You want to have these tools available, but you want to avoid using them as much as possible.

In this chapter we'll focus on the use of `reactiveVal()` and `observe()` to programmatically connect the right hand side of the graph back to the left hand side.
These techniques are powerful because they give you manual control over parts of the graph, but are dangerous because its now your responsibility to make sure you're not doing unnecessary work.
Most importantly, it's now possible to create infinite loops where you app gets stuck in a cycle of updates that never end.

This operation tends to be particularly important when you want to maintain state over time, like you want to know what the user did "last", or accumulate a set of actions into a final results.

You can take these ideas to their logical extremes and provide many tools for programming with reactive.
Two examples of this is [shinySignals](https://github.com/hadley/shinySignals/) and [rxtools](https://github.com/jcheng5/rxtools).
These are both experimental designed primarily to explore ideas.
Wouldn't recommend you use them for anything serious, but reading the source code might be interesting.

```{r}
library(shiny)
```

## Motivation

We'll begin with a few examples of how you might combine `reactiveVal()` and `observe()` to solve a variety of problems that are very difficult to solve otherwise.
These are useful templates for your own apps.

In the first example, we use a common text box that's updated by multiple events (this is rather similar to the framework provided by notifications):

```{r, eval = FALSE}
ui <- fluidPage(
  actionButton("drink", "drink me"),
  actionButton("eat", "eat me"),
  textOutput("notice")
)
server <- function(input, output, session) {
  notice <- reactiveVal("")
  observeEvent(input$drink, notice("You are no longer thirsty"))
  observeEvent(input$eat, notice("You are no longer hungry"))

  output$notice <- renderText(notice())
}
```

Things get slightly more complicated in the next example, where we have an app with two buttons that let you increase and decrease values.
We use a `reactiveVal()` to store the current value, and then use `observeEvent()` to increment and decrement the value when the appropriate button is pushed.
The main additional complexity here is that the new value of `n()` depends on the previous value.

```{r}
ui <- fluidPage(
  actionButton("up", "up"),
  actionButton("down", "down"),
  textOutput("n")
)
server <- function(input, output, session) {
  n <- reactiveVal(0)
  observeEvent(input$up, n(n() + 1))
  observeEvent(input$down, n(n() - 1))
  
  output$n <- renderText(n())
}
```

It's worth taking a moment to draw the reactive graph for this app, as in Figure \@ref(fig:button-graph): the graph is very simple because Shiny can not automatically capture the connection from the observers back to the reactive value that we created.
This graph is the same (with different labels) for the first app.

```{r button-graph, echo = FALSE, out.width = NULL, fig.cap = "The reactive graph does not capture connections from observers to input values"}
knitr::include_graphics("diagrams/reactivity-components.png", dpi = 300)
```

It's a similar pattern if you want to accumulate a list of names as the user does data entry.
Here the main difference is that we use `updateTextInput()` to reset the text box after the user clicks the add button.

```{r}
ui <- fluidPage(
  textInput("name", "name"),
  actionButton("add", "add"),
  textOutput("names")
)
server <- function(input, output, session) {
  names <- reactiveVal()
  observeEvent(input$add, {
    names(c(input$name, names()))
    updateTextInput(session, "name", value = "")
  })
  
  output$names <- renderText(names())
}
```

Another common pattern is to provide a start and stop button that allows you to control some recurring event.
This example uses a `running` reactive value to control whether or not the number increments, using `invalidateLater()` to ensure that the observer is invalidated every 250 ms when running.

```{r}
ui <- fluidPage(
  actionButton("start", "start"),
  actionButton("stop", "stop"),
  textOutput("n")
)
server <- function(input, output, session) {
  running <- reactiveVal(FALSE)
  observeEvent(input$start, running(TRUE))
  observeEvent(input$stop, running(FALSE))
  
  n <- reactiveVal(0)
  observe({
    if (running()) {
      n(isolate(n()) + 1)
      invalidateLater(250)
    }
  })
  output$n <- renderText(n())
}
```

Notice in this case we can't easily use `observeEvent()` because we want to condition on whether or not `running()` is `TRUE`.
It's also very important to note the use of `isolate()` --- if we didn't include this our observer would also take a reactive dependency on `n`, which it updates, and would get stuck in an infinite loop.

Hopefully these examples start to give you a flavour of what programming with `reactiveVal()` and `observer()` feels like.
It's very imperative: when this happens, do that; when that happens, do the other thing.
This makes it easier to understand on a small scale, but harder to understand when bigger pieces start interacting.
So to use effectively you want to keep it as tightly contained as possible.

### Exercises

1.  Provide a server function that draws a histogram of 100 random numbers from a normal distribution when normal is clicked, and 100 random uniforms.

    ```{r}
    ui <- fluidPage(
      actionButton("rnorm", "Normal"),
      actionButton("runif", "Uniform"),
      plotOutput("plot")
    )
    ```

2.  Modify your code from above for this UI:

    ```{r}
    ui <- fluidPage(
      actionButton("type", c("Normal", "Uniform")),
      actionButton("go", "go"),
      plotOutput("plot")
    )
    ```

3.  Rewrite your code above to eliminate any reactive values and observers, and only use `reactive()`.
    Why can you do that for this UI and not the first?

## Anti-patterns

Once you get the hang of this pattern it's easy to fall into bad habits:

```{r}
solution <- function(input, output, session) {
  df <- reactive(head(cars, input$nrows))
  
  output$plot <- renderPlot(plot(df()))
  output$table <- renderTable(df())
}

# Don't need to think in a reactive way
antisolution <- function(input, output, session) {
  df <- reactiveVal(cars)
  observe(df(head(cars, input$nrows)))
  
  output$plot <- renderPlot(plot(df()))
  output$table <- renderTable(df())
}
```

Not a big deal here, although there are still two drawbacks:

-   If the table or plot are in tabs that are not currently visible, the observer will still draw/plot them.

-   If the reactive throws an error, it won't get propagated.

The problem happens when you add more reactives into the mix.
Now if you're not very careful, you'll end up changing *every* reactive consumer whenever any input changes.
Now you've broken completely free from the constraints of Shiny, and you've lost all of the support it gives you.

Your goal should be to build up an accurate mental model of how Shiny's reactive graph works so you can rely on it as much as possible,

## Timers

Another related useful pattern.
Extension of `reactiveTimer()` that we discussed in ...

`reactivePoll()` how is it implemented.

For accurate animation, you should record exactly how much time has elapsed.

Retrying a buggy operation.
Exponential variable back-off

```{r}
last_time <- proc.time()[[3]]
observe({
  # what happens if it takes more a complete interval? how to 
  # decide when to run next
  invalidateLater(round(last_time) - 1)
  takes_a_variable_amount_time()
  last_time <<- proc.time()[[1]]
})
```

### Reactive timer vs invalidate later

```{r}
observe({
  invalidateLater(1000)
  takes_a_long_time()
})

observe({
  on.exit(invalidateLater(1000))
  takes_a_long_time()
})
```
