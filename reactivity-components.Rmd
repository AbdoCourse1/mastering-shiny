# Reactive components {#reactivity-components}

```{r setup, include=FALSE}
source("common.R")
```

## Introduction

Sometimes you need to create new reactive components that don't otherwise exist in Shiny.
These tend to be typically related to managing state over time.
Animations.

Useful because it allows you to break free from some of the constraints of reactive programming.
It allows you to do things that you otherwise could not, but you also lose all the protections you normally get.
You want to have these tools available, but you want to avoid using them as much as possible.

Allows you to programmatically invalidate the left hand side.

If this idea is interesting you might want to read the code in [shinySignals](https://github.com/hadley/shinySignals/), an experimental package that I made to play around with these ideas some time ago.
Wouldn't recommend you use it for anything serious, but reading the source code might be interesting.

`reducePast()`

```{r}
library(shiny)
```

## Motivation

Here are two simple example of what I mean by accumulating state over time.
In the first example, we have an app with two buttons, that let you increase and decrease values.

```{r}
ui <- fluidPage(
  actionButton("up", "up"),
  actionButton("down", "down"),
  textOutput("n")
)
server <- function(input, output, session) {
  n <- reactiveVal(0)
  observeEvent(input$up, n(n() + 1))
  observeEvent(input$down, n(n() - 1))
  
  output$n <- renderText(n())
}
```

Maintain a growing list of entries

```{r}
ui <- fluidPage(
  textInput("name", "name"),
  actionButton("add", "add"),
  textOutput("names")
)
server <- function(input, output, session) {
  names <- reactiveVal()
  observeEvent(input$add, {
    names(c(input$name, names()))
    updateTextInput(session, "name", value = "")
  })
  
  output$names <- renderText(names())
}
```

Single message that multiple observers can "write" to.
Brushing example using different events.

```{r, eval = FALSE}
message <- reactiveVal()
output$widgets <- renderText(messsage())
```

This feels very much like imperative programming --- when this happens, do that.
This makes it easier to understand on a small scale, but harder to understand when bigger pieces start interacting.
So goal is to keep imperative code isolated inside larger functions.

Go + reset buttons.

Pause/play animation.

## Creating components

`reactivePoll()` how is it implemented

Brushing

### Reactive timer vs invalidate later

```{r}
observe({
  invalidateLater(1000)
  takes_a_long_time()
})

observe({
  on.exit(invalidateLater(1000))
  takes_a_long_time()
})

last_time <- NULL
observe({
  # what happens if it takes more a complete interval? how to 
  # decide when to run next
  invalidateLater(round(last_time) - 1)
  takes_a_variable_amount_time()
  last_time <<- proc.time()[[1]]
})
```

Variable back-off

### Observers vs reactives

One caution --- whenever you use `observe()` you force the computation of all reactive expressions.
Often this is not a big deal, but if you are designing tools that compute on reactives, it's good to know about.

Draw out the graph

```{r}
dedupe <- function(r) {
  stopifnot(is.reactive(r))
  
  prev <- reactiveVal(NULL)
  observe({
    val <- r()
    
    isolate({
      if (!identical(val, prev())) {
        prev(val)
      }
    })
  })
  
  reactive(prev())
}

dedupe <- function(r, priority = 100) {
  stopifnot(is.reactive(r))
  
  prev <- reactiveVal(NULL)
  observe(prev(r()), priority = 100)

  reactive(prev())
}
```

```{r}
dedupe <- function(r) {
  stopifnot(is.reactive(r))
  
  prev <- NULL
  reactive({
    val <- r()
    cancelInvalidationIf(!identical(val, prev))
    
    req(!identical(val, prev), cancelOutput = TRUE)

    prev <<- val
    val
  })
}
```

## Anti-patterns

Uniformly inferior:

```{r, eval = FALSE}
x <- reactiveVal(10)
observe(x(input$y * 2))
```

shinyconf talk has more.
